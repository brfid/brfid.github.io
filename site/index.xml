<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Bradley Fidler</title>
    <link>https://www.jockeyholler.net/</link>
    <description>Recent content on Bradley Fidler</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Feb 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.jockeyholler.net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Using CHANGELOG.md as LLM session memory</title>
      <link>https://www.jockeyholler.net/posts/changelog-as-llm-memory/</link>
      <pubDate>Sat, 21 Feb 2026 00:00:00 +0000</pubDate>
      <guid>https://www.jockeyholler.net/posts/changelog-as-llm-memory/</guid>
      <description>&lt;p&gt;Most LLM coding assistants have no memory between sessions. You reload the conversation,
re-explain the project, re-establish context, and hope the model picks up where you left off.
The standard workaround — a large &lt;code&gt;CLAUDE.md&lt;/code&gt; or &lt;code&gt;AGENTS.md&lt;/code&gt; with everything in it — breaks
down quickly. It turns static context into a dumping ground, grows without discipline, and
gives the model no signal about what&amp;rsquo;s &lt;em&gt;currently&lt;/em&gt; changing.&lt;/p&gt;
&lt;p&gt;The fix I landed on is simple: treat &lt;code&gt;CHANGELOG.md [Unreleased]&lt;/code&gt; as the primary mutable
state document.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Most LLM coding assistants have no memory between sessions. You reload the conversation,
re-explain the project, re-establish context, and hope the model picks up where you left off.
The standard workaround — a large <code>CLAUDE.md</code> or <code>AGENTS.md</code> with everything in it — breaks
down quickly. It turns static context into a dumping ground, grows without discipline, and
gives the model no signal about what&rsquo;s <em>currently</em> changing.</p>
<p>The fix I landed on is simple: treat <code>CHANGELOG.md [Unreleased]</code> as the primary mutable
state document.</p>
<h2 id="why-it-works">Why it works</h2>
<p><a href="https://keepachangelog.com/">Keep a Changelog</a> defines a format most LLMs recognize on
sight: a fenced <code>[Unreleased]</code> block at the top, dated releases below. LLMs understand the
convention without being told. They know <code>[Unreleased]</code> is active work and dated entries
are history.</p>
<p>That maps directly onto what you need for session continuity:</p>
<ul>
<li><strong><code>[Unreleased]</code></strong> — mutable, updated every session. Current state, active priorities,
blockers, decisions pending. The model reads this first.</li>
<li><strong>Dated entries</strong> — append-only history. Evidence that decisions happened and why.
The model reads these to reconstruct context if it needs depth.</li>
</ul>
<p>The AGENTS.md (or CLAUDE.md) file becomes stable configuration: conventions, file paths,
source-of-truth map. It changes rarely. The CHANGELOG absorbs the churn.</p>
<h2 id="the-session-start-instruction">The session start instruction</h2>
<p>One line at the top of <code>AGENTS.md</code> is enough:</p>
<pre tabindex="0"><code>Read CHANGELOG.md [Unreleased] at session start.
</code></pre><p>From there the model knows where it is, what&rsquo;s in flight, and what to do next. No
re-explanation needed.</p>
<h2 id="what-goes-in-unreleased">What goes in [Unreleased]</h2>
<p>I use explicit subsections:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl"><span class="gu">## [Unreleased]
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Current State
</span></span></span><span class="line"><span class="cl">One-paragraph snapshot. Where things stand right now.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Active Priorities
</span></span></span><span class="line"><span class="cl">Ordered list of what needs to happen next.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### In Progress
</span></span></span><span class="line"><span class="cl">What the model started in the current session.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Blocked
</span></span></span><span class="line"><span class="cl">Anything waiting on external action.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Decisions Needed
</span></span></span><span class="line"><span class="cl">Open questions the model should surface, not resolve unilaterally.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Recently Completed
</span></span></span><span class="line"><span class="cl">What just shipped. Moves to a dated entry on the next commit.
</span></span></code></pre></div><p>The model updates <code>[Unreleased]</code> at the end of each session. The next session reads it
cold and picks up cleanly.</p>
<h2 id="what-this-is-not">What this is not</h2>
<p>This is not a replacement for good project documentation. Architectural decisions,
integration details, and source-of-truth maps still belong in stable docs. The changelog
is the <em>session state layer</em>, not the full context layer.</p>
<p>It also does not solve the problem of context window limits on large projects. It reduces
the cost of context: the model loads a small, structured, current-state document instead
of scanning a stale megafile.</p>
<h2 id="result">Result</h2>
<p>Sessions are shorter to start, more reliable to hand off, and easier to audit. The
changelog does the work it was always supposed to do — track what changed and when — and
the LLM does less redundant orientation work each time.</p>
<p>The format is well-understood, self-describing, and version-controlled. It costs nothing
to adopt if you are already using Keep a Changelog.</p>
]]></content:encoded>
    </item>
    <item>
      <title>About</title>
      <link>https://www.jockeyholler.net/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.jockeyholler.net/about/</guid>
      <description>About Bradley Fidler</description>
      <content:encoded><![CDATA[<p>Senior technical writer. I work on documentation platforms, AI-assisted authoring
workflows, and the engineering side of content delivery.</p>
<p>This site is <a href="#">jockeyholler.net</a> — a colonial-era name for the neighborhood
where I live, known mostly to local historians.</p>
<ul>
<li><a href="https://www.linkedin.com/in/brfid/">LinkedIn</a></li>
<li><a href="https://github.com/brfid">GitHub</a></li>
<li><a href="mailto:brad@jockeyholler.net">brad@jockeyholler.net</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Work</title>
      <link>https://www.jockeyholler.net/work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.jockeyholler.net/work/</guid>
      <description>Writing samples and documentation portfolio</description>
      <content:encoded><![CDATA[<h2 id="api-reference-and-developer-docs">API Reference and Developer Docs</h2>
<p><strong><a href="https://docs.domaintools.com/feeds/openapi/">Threat Feeds OpenAPI Specification</a></strong> (2025)
OpenAPI 3.0.3 specification for DomainTools Feeds — real-time and batch endpoints, download
workflow, reusable components, examples, and error contracts. Built for code generation,
Swagger UI rendering, and contract validation.</p>
<p><strong><a href="https://docs.domaintools.com/api/">DomainTools API Reference</a></strong> (2025)
API reference documentation for DomainTools data products and endpoints, including the
<a href="https://docs.domaintools.com/api/threat-feeds/">Threat Intelligence Feeds API</a>.</p>
<p><strong><a href="https://docs.domaintools.com/python-sdk/">DomainTools Python SDK</a></strong> (2025)
Developer guide and API reference: installation, authentication, usage patterns, method reference.</p>
<p><strong><a href="https://docs.domaintools.com">DomainTools Product Documentation</a></strong> (2025)
User-facing documentation for DomainTools security intelligence products and workflows.</p>
<hr>
<h2 id="llm-and-ai-documentation">LLM and AI Documentation</h2>
<p>Auto-generated structured context files covering DomainTools API products and data schemas,
produced by CI/CD pipeline for use in LLM tooling and retrieval workflows. (Internal; not publicly linked.)</p>
<hr>
<h2 id="research-and-commissioned-history">Research and Commissioned History</h2>
<p><strong><a href="https://www.icann.org/en/system/files/files/creation-administration-unique-identifiers-1967-2017-18nov20-en.pdf">The Creation and Administration of Unique Identifiers, 1967–2017</a></strong> (2020)
Comprehensive history of internet unique identifier creation and administration from ARPANET
origins through 2017. Co-authored with Russ Mundy; jointly commissioned by ICANN and Google.
Foreword by Vint Cerf and Steve Crocker.</p>
<p><strong><a href="https://www.usenix.org/conference/usenixsecurity23/presentation/jones">Work-From-Home and COVID-19: Trajectories of Endpoint Security Management in a Security Operations Center</a></strong> (2023)
Peer-reviewed paper at USENIX Security &lsquo;23. Co-authored historical analysis tracing endpoint
security management from the 1970s through the COVID-19 WFH transition, complementing a
1,000-hour SOC ethnography study.</p>
<p><strong><a href="https://doi.org/10.1109/MAHC.2016.49">Edge Cryptography and the Codevelopment of Computer Networks and Cybersecurity</a></strong> (2016)
Peer-reviewed article in IEEE Annals of the History of Computing.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
