<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="dark">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Using CHANGELOG.md as LLM session memory | Bradley Fidler</title>
<meta name="keywords" content="llm, documentation, workflow">
<meta name="description" content="Most LLM coding assistants have no memory between sessions. You reload the conversation,
re-explain the project, re-establish context, and hope the model picks up where you left off.
The standard workaround — a large CLAUDE.md or AGENTS.md with everything in it — breaks
down quickly. It turns static context into a dumping ground, grows without discipline, and
gives the model no signal about what&rsquo;s currently changing.
The fix I landed on is simple: treat CHANGELOG.md [Unreleased] as the primary mutable
state document.">
<meta name="author" content="Bradley Fidler">
<link rel="canonical" href="https://www.jockeyholler.net/posts/changelog-as-llm-memory/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.jockeyholler.net/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.jockeyholler.net/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.jockeyholler.net/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.jockeyholler.net/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.jockeyholler.net/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.jockeyholler.net/posts/changelog-as-llm-memory/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://www.jockeyholler.net/posts/changelog-as-llm-memory/">
  <meta property="og:site_name" content="Bradley Fidler">
  <meta property="og:title" content="Using CHANGELOG.md as LLM session memory">
  <meta property="og:description" content="Most LLM coding assistants have no memory between sessions. You reload the conversation, re-explain the project, re-establish context, and hope the model picks up where you left off. The standard workaround — a large CLAUDE.md or AGENTS.md with everything in it — breaks down quickly. It turns static context into a dumping ground, grows without discipline, and gives the model no signal about what’s currently changing.
The fix I landed on is simple: treat CHANGELOG.md [Unreleased] as the primary mutable state document.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-21T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-02-21T00:00:00+00:00">
    <meta property="article:tag" content="Llm">
    <meta property="article:tag" content="Documentation">
    <meta property="article:tag" content="Workflow">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Using CHANGELOG.md as LLM session memory">
<meta name="twitter:description" content="Most LLM coding assistants have no memory between sessions. You reload the conversation,
re-explain the project, re-establish context, and hope the model picks up where you left off.
The standard workaround — a large CLAUDE.md or AGENTS.md with everything in it — breaks
down quickly. It turns static context into a dumping ground, grows without discipline, and
gives the model no signal about what&rsquo;s currently changing.
The fix I landed on is simple: treat CHANGELOG.md [Unreleased] as the primary mutable
state document.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Writing",
      "item": "https://www.jockeyholler.net/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Using CHANGELOG.md as LLM session memory",
      "item": "https://www.jockeyholler.net/posts/changelog-as-llm-memory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Using CHANGELOG.md as LLM session memory",
  "name": "Using CHANGELOG.md as LLM session memory",
  "description": "Most LLM coding assistants have no memory between sessions. You reload the conversation, re-explain the project, re-establish context, and hope the model picks up where you left off. The standard workaround — a large CLAUDE.md or AGENTS.md with everything in it — breaks down quickly. It turns static context into a dumping ground, grows without discipline, and gives the model no signal about what\u0026rsquo;s currently changing.\nThe fix I landed on is simple: treat CHANGELOG.md [Unreleased] as the primary mutable state document.\n",
  "keywords": [
    "llm", "documentation", "workflow"
  ],
  "articleBody": "Most LLM coding assistants have no memory between sessions. You reload the conversation, re-explain the project, re-establish context, and hope the model picks up where you left off. The standard workaround — a large CLAUDE.md or AGENTS.md with everything in it — breaks down quickly. It turns static context into a dumping ground, grows without discipline, and gives the model no signal about what’s currently changing.\nThe fix I landed on is simple: treat CHANGELOG.md [Unreleased] as the primary mutable state document.\nWhy it works Keep a Changelog defines a format most LLMs recognize on sight: a fenced [Unreleased] block at the top, dated releases below. LLMs understand the convention without being told. They know [Unreleased] is active work and dated entries are history.\nThat maps directly onto what you need for session continuity:\n[Unreleased] — mutable, updated every session. Current state, active priorities, blockers, decisions pending. The model reads this first. Dated entries — append-only history. Evidence that decisions happened and why. The model reads these to reconstruct context if it needs depth. The AGENTS.md (or CLAUDE.md) file becomes stable configuration: conventions, file paths, source-of-truth map. It changes rarely. The CHANGELOG absorbs the churn.\nThe session start instruction One line at the top of AGENTS.md is enough:\nRead CHANGELOG.md [Unreleased] at session start. From there the model knows where it is, what’s in flight, and what to do next. No re-explanation needed.\nWhat goes in [Unreleased] I use explicit subsections:\n## [Unreleased] ### Current State One-paragraph snapshot. Where things stand right now. ### Active Priorities Ordered list of what needs to happen next. ### In Progress What the model started in the current session. ### Blocked Anything waiting on external action. ### Decisions Needed Open questions the model should surface, not resolve unilaterally. ### Recently Completed What just shipped. Moves to a dated entry on the next commit. The model updates [Unreleased] at the end of each session. The next session reads it cold and picks up cleanly.\nWhat this is not This is not a replacement for good project documentation. Architectural decisions, integration details, and source-of-truth maps still belong in stable docs. The changelog is the session state layer, not the full context layer.\nIt also does not solve the problem of context window limits on large projects. It reduces the cost of context: the model loads a small, structured, current-state document instead of scanning a stale megafile.\nResult Sessions are shorter to start, more reliable to hand off, and easier to audit. The changelog does the work it was always supposed to do — track what changed and when — and the LLM does less redundant orientation work each time.\nThe format is well-understood, self-describing, and version-controlled. It costs nothing to adopt if you are already using Keep a Changelog.\n",
  "wordCount" : "463",
  "inLanguage": "en",
  "datePublished": "2026-02-21T00:00:00Z",
  "dateModified": "2026-02-21T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Bradley Fidler"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.jockeyholler.net/posts/changelog-as-llm-memory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Bradley Fidler",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.jockeyholler.net/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.jockeyholler.net/" accesskey="h" title="Bradley Fidler (Alt + H)">Bradley Fidler</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.jockeyholler.net/posts/" title="Writing">
                    <span>Writing</span>
                </a>
            </li>
            <li>
                <a href="https://www.jockeyholler.net/work/" title="Work">
                    <span>Work</span>
                </a>
            </li>
            <li>
                <a href="https://www.jockeyholler.net/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Using CHANGELOG.md as LLM session memory
    </h1>
    <div class="post-meta"><span title='2026-02-21 00:00:00 +0000 UTC'>February 21, 2026</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Bradley Fidler</span>

</div>
  </header> 
  <div class="post-content"><p>Most LLM coding assistants have no memory between sessions. You reload the conversation,
re-explain the project, re-establish context, and hope the model picks up where you left off.
The standard workaround — a large <code>CLAUDE.md</code> or <code>AGENTS.md</code> with everything in it — breaks
down quickly. It turns static context into a dumping ground, grows without discipline, and
gives the model no signal about what&rsquo;s <em>currently</em> changing.</p>
<p>The fix I landed on is simple: treat <code>CHANGELOG.md [Unreleased]</code> as the primary mutable
state document.</p>
<h2 id="why-it-works">Why it works<a hidden class="anchor" aria-hidden="true" href="#why-it-works">#</a></h2>
<p><a href="https://keepachangelog.com/">Keep a Changelog</a> defines a format most LLMs recognize on
sight: a fenced <code>[Unreleased]</code> block at the top, dated releases below. LLMs understand the
convention without being told. They know <code>[Unreleased]</code> is active work and dated entries
are history.</p>
<p>That maps directly onto what you need for session continuity:</p>
<ul>
<li><strong><code>[Unreleased]</code></strong> — mutable, updated every session. Current state, active priorities,
blockers, decisions pending. The model reads this first.</li>
<li><strong>Dated entries</strong> — append-only history. Evidence that decisions happened and why.
The model reads these to reconstruct context if it needs depth.</li>
</ul>
<p>The AGENTS.md (or CLAUDE.md) file becomes stable configuration: conventions, file paths,
source-of-truth map. It changes rarely. The CHANGELOG absorbs the churn.</p>
<h2 id="the-session-start-instruction">The session start instruction<a hidden class="anchor" aria-hidden="true" href="#the-session-start-instruction">#</a></h2>
<p>One line at the top of <code>AGENTS.md</code> is enough:</p>
<pre tabindex="0"><code>Read CHANGELOG.md [Unreleased] at session start.
</code></pre><p>From there the model knows where it is, what&rsquo;s in flight, and what to do next. No
re-explanation needed.</p>
<h2 id="what-goes-in-unreleased">What goes in [Unreleased]<a hidden class="anchor" aria-hidden="true" href="#what-goes-in-unreleased">#</a></h2>
<p>I use explicit subsections:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl"><span class="gu">## [Unreleased]
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Current State
</span></span></span><span class="line"><span class="cl">One-paragraph snapshot. Where things stand right now.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Active Priorities
</span></span></span><span class="line"><span class="cl">Ordered list of what needs to happen next.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### In Progress
</span></span></span><span class="line"><span class="cl">What the model started in the current session.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Blocked
</span></span></span><span class="line"><span class="cl">Anything waiting on external action.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Decisions Needed
</span></span></span><span class="line"><span class="cl">Open questions the model should surface, not resolve unilaterally.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gu">### Recently Completed
</span></span></span><span class="line"><span class="cl">What just shipped. Moves to a dated entry on the next commit.
</span></span></code></pre></div><p>The model updates <code>[Unreleased]</code> at the end of each session. The next session reads it
cold and picks up cleanly.</p>
<h2 id="what-this-is-not">What this is not<a hidden class="anchor" aria-hidden="true" href="#what-this-is-not">#</a></h2>
<p>This is not a replacement for good project documentation. Architectural decisions,
integration details, and source-of-truth maps still belong in stable docs. The changelog
is the <em>session state layer</em>, not the full context layer.</p>
<p>It also does not solve the problem of context window limits on large projects. It reduces
the cost of context: the model loads a small, structured, current-state document instead
of scanning a stale megafile.</p>
<h2 id="result">Result<a hidden class="anchor" aria-hidden="true" href="#result">#</a></h2>
<p>Sessions are shorter to start, more reliable to hand off, and easier to audit. The
changelog does the work it was always supposed to do — track what changed and when — and
the LLM does less redundant orientation work each time.</p>
<p>The format is well-understood, self-describing, and version-controlled. It costs nothing
to adopt if you are already using Keep a Changelog.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.jockeyholler.net/tags/llm/">Llm</a></li>
      <li><a href="https://www.jockeyholler.net/tags/documentation/">Documentation</a></li>
      <li><a href="https://www.jockeyholler.net/tags/workflow/">Workflow</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://www.jockeyholler.net/">Bradley Fidler</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
