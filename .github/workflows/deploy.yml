name: Publish Site

# Mode 1: Fast local publish tags
# Mode 2: Distributed vintage publish tags (VAX build host + PDP-11 validation)

on:
  push:
    tags:
      - "publish-vintage"     # Mode 2: Distributed vintage pipeline
      - "publish-vintage-*"   # Mode 2: Distributed vintage variants
      - "publish-vax"         # Mode 2 legacy alias
      - "publish-vax-*"       # Mode 2 legacy alias
      - "publish-docker"      # Mode 2 legacy alias
      - "publish-docker-*"    # Mode 2 legacy alias
      - "publish"           # Mode 1: Fast (local)
      - "publish-fast"      # Mode 1: Fast (explicit)
      - "publish-fast-*"    # Mode 1: Fast variants
  workflow_dispatch:
    inputs:
      build_mode:
        description: 'Build mode (local or distributed vintage backend)'
        required: true
        default: 'local'
        type: choice
        options:
          - local
          - docker

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: "pyproject.toml"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install -e '.[dev]'

      - name: Quality checks
        run: |
          # Keep publish checks aligned with CI/test policy to avoid unrelated
          # full-repo lint/type failures during deployment runs.
          python -m ruff check resume_generator
          python -m mypy resume_generator host_logging tests
          python -m pytest -q -m "unit and not docker and not slow"
          python -m pylint resume_generator -sn
          python -m vulture --config pyproject.toml resume_generator

      - name: Determine build mode
        id: mode
        run: |
          # Determine mode based on tag name
          TAG_NAME="${{ github.ref_name }}"

          if [[ "$TAG_NAME" == *"vax"* ]] || [[ "$TAG_NAME" == *"docker"* ]] || [[ "$TAG_NAME" == *"vintage"* ]] || [[ "$TAG_NAME" == *"distributed"* ]]; then
            echo "build_mode=docker" >> $GITHUB_OUTPUT
            echo "mode_name=Distributed vintage (authentic build)" >> $GITHUB_OUTPUT
            echo "üöÄ Building with distributed vintage mode (authentic BSD pipeline)"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "build_mode=${{ inputs.build_mode }}" >> $GITHUB_OUTPUT
            echo "mode_name=Manual (${{ inputs.build_mode }})" >> $GITHUB_OUTPUT
            echo "üéÆ Building with manual mode: ${{ inputs.build_mode }}"
          else
            echo "build_mode=local" >> $GITHUB_OUTPUT
            echo "mode_name=Local (fast)" >> $GITHUB_OUTPUT
            echo "‚ö° Building with local mode (fast)"
          fi

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('**/pyproject.toml') }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Install Playwright browsers
        run: python -m playwright install --with-deps chromium

      - name: Generate build ID
        if: steps.mode.outputs.build_mode == 'docker'
        id: build_id
        run: |
          BUILD_ID="build-$(date -u '+%Y%m%d-%H%M%S')"
          echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
          echo "üìù Build ID: $BUILD_ID"

      - name: Setup edcloud SSH key
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          EDCLOUD_SSH_PRIVATE_KEY: ${{ secrets.EDCLOUD_SSH_PRIVATE_KEY }}
          AWS_SSH_PRIVATE_KEY: ${{ secrets.AWS_SSH_PRIVATE_KEY }}
        run: |
          KEY="${EDCLOUD_SSH_PRIVATE_KEY:-$AWS_SSH_PRIVATE_KEY}"
          if [[ -z "$KEY" ]]; then
            echo "Missing SSH private key secret (EDCLOUD_SSH_PRIVATE_KEY or AWS_SSH_PRIVATE_KEY)."
            exit 1
          fi
          echo "$KEY" > /tmp/aws-key.pem
          chmod 600 /tmp/aws-key.pem

      - name: Activate edcloud infrastructure
        if: steps.mode.outputs.build_mode == 'docker'
        id: edcloud_activate
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          EDCLOUD_INSTANCE_ID: ${{ secrets.EDCLOUD_INSTANCE_ID }}
        run: |
          ts() { date -u '+%Y-%m-%d %H:%M:%S'; }

          INSTANCE_ID="${EDCLOUD_INSTANCE_ID}"
          if [[ -z "$INSTANCE_ID" ]]; then
            INSTANCE_ID="$(aws ec2 describe-instances \
              --filters \
                Name=tag:edcloud:managed,Values=true \
                Name=tag:Name,Values=edcloud \
                Name=instance-state-name,Values=pending,running,stopping,stopped \
              --query "Reservations[].Instances[] | sort_by(@, &LaunchTime)[-1].InstanceId" \
              --output text)"
          fi
          if [[ -z "$INSTANCE_ID" || "$INSTANCE_ID" == "None" ]]; then
            echo "‚ùå No edcloud instance found (set EDCLOUD_INSTANCE_ID or tag instance)."
            exit 1
          fi

          echo "[$(ts) GITHUB] EDCLOUD_ACTIVATE_BEGIN instance_id=$INSTANCE_ID" >> /tmp/github.log
          echo "üöÄ Starting edcloud instance..."
          aws ec2 start-instances --instance-ids "$INSTANCE_ID" >/dev/null

          echo "‚è≥ Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"

          echo "üì° Getting instance IP..."
          EDCLOUD_IP=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          if [[ -z "$EDCLOUD_IP" || "$EDCLOUD_IP" == "None" ]]; then
            echo "‚ùå Failed to resolve edcloud public IP"
            echo "[$(ts) GITHUB] EDCLOUD_ACTIVATE_FAILED reason=missing_public_ip" >> /tmp/github.log
            exit 1
          fi

          wait_for_ssh() {
            local name="$1"
            local ip="$2"
            local ready=0
            echo "‚è≥ Waiting for SSH on $name ($ip)..."
            for i in {1..30}; do
              if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i /tmp/aws-key.pem "ubuntu@$ip" echo "ready" >/dev/null 2>&1; then
                ready=1
                echo "‚úÖ SSH ready on $name"
                break
              fi
              echo "Attempt $i/30: SSH not ready yet on $name..."
              sleep 10
            done
            if [[ "$ready" -ne 1 ]]; then
              echo "‚ùå SSH readiness timeout for $name ($ip)"
              echo "[$(ts) GITHUB] EDCLOUD_ACTIVATE_FAILED reason=ssh_timeout host=$name ip=$ip" >> /tmp/github.log
              exit 1
            fi
          }

          wait_for_ssh "edcloud" "$EDCLOUD_IP"

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "edcloud_ip=$EDCLOUD_IP" >> $GITHUB_OUTPUT
          # Keep legacy output names for downstream steps.
          echo "vax_ip=$EDCLOUD_IP" >> $GITHUB_OUTPUT
          echo "pdp11_ip=$EDCLOUD_IP" >> $GITHUB_OUTPUT
          echo "[$(ts) GITHUB] EDCLOUD_ACTIVATE_READY instance_id=$INSTANCE_ID ip=$EDCLOUD_IP" >> /tmp/github.log
          echo "‚úÖ edcloud infrastructure activated"

      - name: Prepare edcloud host
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          EDCLOUD_IP: ${{ steps.edcloud_activate.outputs.edcloud_ip }}
          GIT_SHA: ${{ github.sha }}
        run: |
          echo "üõ†Ô∏è Preparing edcloud host runtime..."

          ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$EDCLOUD_IP "bash -se" <<EOF
          set -euo pipefail

          if [[ ! -d "\$HOME/brfid.github.io/.git" ]]; then
            git clone https://github.com/brfid/brfid.github.io.git "\$HOME/brfid.github.io"
          fi

          cd "\$HOME/brfid.github.io"
          git fetch --all --prune
          git checkout "$GIT_SHA"
          mkdir -p build/vax build/pdp11

          sudo mkdir -p /mnt/arpanet-logs/builds
          sudo chown -R ubuntu:ubuntu /mnt/arpanet-logs

          docker compose -f docker-compose.production.yml up -d --build
          docker compose -f docker-compose.production.yml ps
          EOF

          echo "‚úÖ edcloud host prepared"

      - name: Transfer scripts to edcloud
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          EDCLOUD_IP: ${{ steps.edcloud_activate.outputs.edcloud_ip }}
        run: |
          echo "üì§ Transferring scripts to edcloud host..."

          scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
            scripts/arpanet-log.sh \
            scripts/vax-build-and-encode.sh \
            scripts/merge-logs.py \
            scripts/extract-vax-logs.py \
            scripts/extract-pdp11-logs.py \
            ubuntu@$EDCLOUD_IP:/tmp/

          ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$EDCLOUD_IP \
            'chmod +x /tmp/*.sh /tmp/*.py'

          echo "‚úÖ Scripts transferred to edcloud host"

      - name: Stage 1 - VAX Build & Encode
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          VAX_IP: ${{ steps.edcloud_activate.outputs.vax_ip }}
          BUILD_ID: ${{ steps.build_id.outputs.build_id }}
        run: |
          echo "=== STAGE 1: VAX BUILD & ENCODE ==="
          echo "VAX IP: $VAX_IP"
          echo "Build ID: $BUILD_ID"

          # Log GitHub Actions activity
          exec > >(tee >(while IFS= read -r line; do echo "[$(date -u '+%Y-%m-%d %H:%M:%S') GITHUB] $line"; done >> /tmp/github.log)) 2>&1

          # Generate resume.vax.yaml locally
          echo "Generating resume.vax.yaml locally..."
          python -m resume_generator --out site --with-vax --vax-mode local

          # Install screen for console automation
          if ! command -v screen &> /dev/null; then
            echo "Installing screen..."
            sudo apt-get update -qq
            sudo apt-get install -y screen
          fi

          # Upload arpanet-log.sh to VAX BSD via console
          echo "Uploading arpanet-log.sh to VAX BSD..."
          bash scripts/vax-console-upload.sh scripts/arpanet-log.sh /tmp/arpanet-log.sh "$VAX_IP"

          # Make it executable inside BSD
          SESSION="vax-chmod-$$"
          screen -dmS "$SESSION" telnet "$VAX_IP" 2323
          sleep 3
          screen -S "$SESSION" -X stuff "\n"
          sleep 0.5
          screen -S "$SESSION" -X stuff "root\n"
          sleep 2
          screen -S "$SESSION" -X stuff "chmod +x /tmp/arpanet-log.sh\n"
          sleep 1
          screen -S "$SESSION" -X quit 2>/dev/null || true

          # Upload source files to VAX BSD via console
          echo "Uploading bradman.c to VAX BSD..."
          bash scripts/vax-console-upload.sh vax/bradman.c /tmp/bradman.c "$VAX_IP"

          echo "Uploading resume.vax.yaml to VAX BSD..."
          bash scripts/vax-console-upload.sh build/vax/resume.vax.yaml /tmp/resume.vax.yaml "$VAX_IP"

          # Upload build script to VAX BSD via console
          echo "Uploading vax-build-and-encode.sh to VAX BSD..."
          bash scripts/vax-console-upload.sh scripts/vax-build-and-encode.sh /tmp/vax-build-and-encode.sh "$VAX_IP"

          # Make build script executable inside BSD
          screen -dmS "$SESSION" telnet "$VAX_IP" 2323
          sleep 3
          screen -S "$SESSION" -X stuff "\n"
          sleep 0.5
          screen -S "$SESSION" -X stuff "root\n"
          sleep 2
          screen -S "$SESSION" -X stuff "chmod +x /tmp/vax-build-and-encode.sh\n"
          sleep 1
          screen -S "$SESSION" -X quit 2>/dev/null || true

          # Execute build script INSIDE VAX BSD
          echo "Executing build inside VAX BSD (vintage K&R C)..."
          SESSION="vax-build-$$"
          screen -dmS "$SESSION" telnet "$VAX_IP" 2323
          sleep 3
          screen -S "$SESSION" -X stuff "\n"
          sleep 0.5
          screen -S "$SESSION" -X stuff "root\n"
          sleep 2
          screen -S "$SESSION" -X stuff "cd /tmp\n"
          sleep 1
          screen -S "$SESSION" -X stuff "/tmp/vax-build-and-encode.sh $BUILD_ID\n"

          # Wait for build to complete (adjust timing as needed)
          echo "Waiting for build to complete..."
          sleep 30

          # Capture console output
          screen -S "$SESSION" -X hardcopy "/tmp/vax-build-console.txt"
          screen -S "$SESSION" -X quit 2>/dev/null || true

          # Extract logs from console capture
          echo "Extracting logs from console output..."

          if [ -f /tmp/vax-build-console.txt ]; then
            # Verify build succeeded
            if grep -q "VAX build complete" /tmp/vax-build-console.txt; then
              echo "‚úì Build succeeded (verified via console)"

              # Upload console capture to container for processing
              scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
                /tmp/vax-build-console.txt \
                ubuntu@$VAX_IP:/tmp/vax-build-console.txt

              # Extract logs from console capture to host log storage
              ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
                "mkdir -p /mnt/arpanet-logs/builds/$BUILD_ID && \
                 python3 /tmp/extract-vax-logs.py \
                   /tmp/vax-build-console.txt \
                   /mnt/arpanet-logs/builds/$BUILD_ID/VAX.log"

              echo "‚úì Logs extracted to host log storage"
            else
              echo "‚ö†Ô∏è  Build status unclear from console output"
              echo "Console output (last 50 lines):"
              tail -50 /tmp/vax-build-console.txt
            fi
          else
            echo "‚ö†Ô∏è  Console capture not found"
          fi

          echo "‚úì VAX build & encode complete (executed in BSD with vintage tools)"

      - name: Stage 2 - Console Transfer (VAX ‚Üí PDP-11)
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          VAX_IP: ${{ steps.edcloud_activate.outputs.vax_ip }}
          PDP11_IP: ${{ steps.edcloud_activate.outputs.pdp11_ip }}
          BUILD_ID: ${{ steps.build_id.outputs.build_id }}
        run: |
          echo "=== STAGE 2: CONSOLE TRANSFER ==="
          echo "VAX IP: $VAX_IP"
          echo "PDP-11 IP: $PDP11_IP"
          echo "Build ID: $BUILD_ID"

          # Retrieve encoded file from VAX BSD via console cat
          echo "Retrieving encoded file from VAX BSD..."
          SESSION="vax-retrieve-$$"
          screen -dmS "$SESSION" telnet "$VAX_IP" 2323
          sleep 3
          screen -S "$SESSION" -X stuff "\n"
          sleep 0.5
          screen -S "$SESSION" -X stuff "root\n"
          sleep 2
          screen -S "$SESSION" -X stuff "cat /tmp/brad.1.uu\n"
          sleep 5
          screen -S "$SESSION" -X hardcopy "/tmp/vax-cat-output.txt"
          screen -S "$SESSION" -X quit 2>/dev/null || true

          # Extract just the uuencoded content (skip prompts)
          grep -E '^(begin|M|end)' /tmp/vax-cat-output.txt > /tmp/brad.1.uu || echo "Warning: Could not extract uuencoded file"

          # Verify we got the file
          if [ -f /tmp/brad.1.uu ] && [ -s /tmp/brad.1.uu ]; then
            echo "‚úì Retrieved brad.1.uu ($(wc -l < /tmp/brad.1.uu) lines)"
          else
            echo "‚ùå Failed to retrieve brad.1.uu from VAX BSD"
            exit 1
          fi

          # Upload arpanet-log.sh to PDP-11 BSD
          echo "Uploading arpanet-log.sh to PDP-11 BSD..."

          # Create a console upload helper for PDP-11
          SESSION="pdp11-upload-$$"
          screen -dmS "$SESSION" telnet "$PDP11_IP" 2327
          sleep 3
          screen -S "$SESSION" -X stuff "\n"
          sleep 0.5
          screen -S "$SESSION" -X stuff "root\n"
          sleep 2

          # Upload arpanet-log.sh via heredoc
          screen -S "$SESSION" -X stuff "cat > /tmp/arpanet-log.sh << 'UPLOAD_EOF'\n"
          sleep 0.5

          while IFS= read -r line; do
            screen -S "$SESSION" -X stuff "$line\r"
            sleep 0.02
          done < scripts/arpanet-log.sh

          screen -S "$SESSION" -X stuff "UPLOAD_EOF\n"
          sleep 1
          screen -S "$SESSION" -X stuff "chmod +x /tmp/arpanet-log.sh\n"
          sleep 1
          screen -S "$SESSION" -X quit 2>/dev/null || true

          echo "‚úì arpanet-log.sh uploaded to PDP-11 BSD"

          # Run console transfer
          echo "Starting console transfer to PDP-11..."
          python3 scripts/console-transfer.py "$BUILD_ID" "$VAX_IP" "$PDP11_IP"

          echo "‚úì Console transfer complete"

      - name: Verify screen session persists
        if: steps.mode.outputs.build_mode == 'docker'
        run: |
          echo "üì° Verifying screen session..."
          if screen -ls | grep -q "pdp11-console"; then
            echo "‚úÖ Screen session 'pdp11-console' is active"
            screen -ls
          else
            echo "‚ùå Screen session 'pdp11-console' not found"
            echo "Available sessions:"
            screen -ls || echo "No screen sessions found"
            echo "Processes:"
            ps aux | grep screen || true
            exit 1
          fi

      - name: Stage 3 - PDP-11 Validation
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          BUILD_ID: ${{ steps.build_id.outputs.build_id }}
          PDP11_IP: ${{ steps.edcloud_activate.outputs.pdp11_ip }}
          VAX_IP: ${{ steps.edcloud_activate.outputs.vax_ip }}
        run: |
          echo "=== STAGE 3: PDP-11 VALIDATION ==="
          echo "Build ID: $BUILD_ID"
          echo "PDP-11 IP: $PDP11_IP"

          # Run validation commands on PDP-11 console
          echo "Sending validation commands to PDP-11..."
          bash scripts/pdp11-validate.sh "$BUILD_ID"

          # Extract logs from PDP-11 console capture
          echo "Extracting PDP-11 logs from console output..."

          if [ -f /tmp/pdp11-validation-$BUILD_ID.txt ]; then
            # Verify validation succeeded
            if grep -q "Status: PASS" /tmp/pdp11-validation-$BUILD_ID.txt; then
              echo "‚úì Validation succeeded (verified via console)"

              # Upload console capture to container for processing
              scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
                /tmp/pdp11-validation-$BUILD_ID.txt \
                ubuntu@$VAX_IP:/tmp/pdp11-validation-$BUILD_ID.txt

              # Extract logs from console capture to host log storage
              ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
                "mkdir -p /mnt/arpanet-logs/builds/$BUILD_ID && \
                 python3 /tmp/extract-pdp11-logs.py \
                   /tmp/pdp11-validation-$BUILD_ID.txt \
                   /mnt/arpanet-logs/builds/$BUILD_ID/PDP11.log"

              echo "‚úì PDP-11 logs extracted to host log storage"
            else
              echo "‚ö†Ô∏è  Validation status unclear from console output"
              echo "Console output (last 50 lines):"
              tail -50 /tmp/pdp11-validation-$BUILD_ID.txt
            fi
          else
            echo "‚ö†Ô∏è  PDP-11 console capture not found"
          fi

          echo "‚úì PDP-11 validation complete"

      - name: Stage 4 - Retrieve Final Output
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          VAX_IP: ${{ steps.edcloud_activate.outputs.vax_ip }}
          BUILD_ID: ${{ steps.build_id.outputs.build_id }}
        run: |
          echo "=== STAGE 4: RETRIEVE FINAL OUTPUT ==="

          # Retrieve validated output from host log storage
          echo "Retrieving validated output from PDP-11..."
          scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
            ubuntu@$VAX_IP:/mnt/arpanet-logs/builds/$BUILD_ID/pdp-output/brad.txt \
            build/vax/brad.txt || echo "Warning: brad.txt not found, using original"

          # Fallback: if PDP-11 output not available, get from VAX
          if [[ ! -f build/vax/brad.txt ]]; then
            echo "Using VAX original output..."
            scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
              ubuntu@$VAX_IP:/tmp/brad.1 \
              build/vax/brad.1
            python -m resume_generator.manpage --in build/vax/brad.1 --out build/vax/brad.txt
          fi

          # Copy to site
          cp build/vax/brad.txt site/brad.man.txt

          echo "‚úì Final output retrieved"

      - name: Generate site (Local mode fallback)
        if: steps.mode.outputs.build_mode != 'docker'
        run: |
          python -m resume_generator --out site --with-vax \
            --vax-mode ${{ steps.mode.outputs.build_mode }}

      - name: Merge and retrieve build logs
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          VAX_IP: ${{ steps.edcloud_activate.outputs.vax_ip }}
          BUILD_ID: ${{ steps.build_id.outputs.build_id }}
        run: |
          echo "üìã Merging build logs from all sources..."

          # Ensure build directory exists on host log storage
          ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
            "mkdir -p /mnt/arpanet-logs/builds/$BUILD_ID"

          # Upload GitHub log to host log storage
          if [[ -f /tmp/github.log ]]; then
            echo "Uploading GitHub Actions log..."
            scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
              /tmp/github.log \
              ubuntu@$VAX_IP:/mnt/arpanet-logs/builds/$BUILD_ID/GITHUB.log
          fi

          # Upload COURIER log to host log storage
          if [[ -f /tmp/COURIER-$BUILD_ID.log ]]; then
            echo "Uploading COURIER log..."
            scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
              /tmp/COURIER-$BUILD_ID.log \
              ubuntu@$VAX_IP:/mnt/arpanet-logs/builds/$BUILD_ID/COURIER.log
          fi

          # Verify all log sources exist
          echo "Checking log sources..."
          ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
            "ls -lh /mnt/arpanet-logs/builds/$BUILD_ID/*.log"

          # Merge logs chronologically (VAX, PDP11, COURIER, GITHUB)
          echo "Merging logs chronologically..."
          ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
            "python3 /tmp/merge-logs.py $BUILD_ID"

          # Retrieve all logs
          echo "Retrieving build logs..."
          mkdir -p site/build-logs

          # Retrieve merged log
          scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
            ubuntu@$VAX_IP:/mnt/arpanet-logs/builds/$BUILD_ID/merged.log \
            site/build-logs/merged.log

          # Retrieve individual component logs
          for component in VAX PDP11 COURIER GITHUB; do
            if ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
              "test -f /mnt/arpanet-logs/builds/$BUILD_ID/${component}.log"; then
              echo "Retrieving ${component}.log..."
              scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
                ubuntu@$VAX_IP:/mnt/arpanet-logs/builds/$BUILD_ID/${component}.log \
                site/build-logs/${component}.log
            else
              echo "Warning: ${component}.log not found"
            fi
          done

          # Cleanup old builds (keep last 20)
          echo "Cleaning up old builds in host log storage..."
          ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
            'cd /mnt/arpanet-logs/builds && ls -t | tail -n +21 | xargs -r rm -rf'

          echo "‚úÖ Logs merged and retrieved from all sources"

      - name: Generate enterprise logs page
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          BUILD_ID: ${{ steps.build_id.outputs.build_id }}
        run: |
          echo "üìÑ Generating enterprise logs page..."

          python3 scripts/generate-logs-page.py \
            --build-id "$BUILD_ID" \
            --merged site/build-logs/merged.log \
            --output site/logs/index.html

          echo "‚úÖ Logs page generated at site/logs/index.html"

      - name: Generate build info widget
        if: steps.mode.outputs.build_mode == 'docker'
        env:
          VAX_IP: ${{ steps.edcloud_activate.outputs.vax_ip }}
          BUILD_ID: ${{ steps.build_id.outputs.build_id }}
        run: |
          echo "üìä Generating build info widget..."

          # Transfer generate-build-info.py to VAX
          scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
            scripts/generate-build-info.py \
            ubuntu@$VAX_IP:/tmp/generate-build-info.py

          ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
            'chmod +x /tmp/generate-build-info.py'

          # Generate build info on VAX
          ssh -o StrictHostKeyChecking=no -i /tmp/aws-key.pem ubuntu@$VAX_IP \
            "python3 /tmp/generate-build-info.py $BUILD_ID /mnt/arpanet-logs /tmp/build-info"

          # Retrieve generated files
          mkdir -p site/build-info
          scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
            ubuntu@$VAX_IP:/tmp/build-info/build-info.json \
            site/build-info/

          scp -o StrictHostKeyChecking=no -i /tmp/aws-key.pem \
            ubuntu@$VAX_IP:/tmp/build-info/build-info.html \
            site/build-info/

          # Copy CSS
          cp templates/build-info.css site/build-info/

          echo "‚úÖ Build info widget generated"

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Deactivate edcloud infrastructure
        if: always() && steps.mode.outputs.build_mode == 'docker'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          EDCLOUD_INSTANCE_ID: ${{ secrets.EDCLOUD_INSTANCE_ID }}
          ACTIVATED_INSTANCE_ID: ${{ steps.edcloud_activate.outputs.instance_id }}
        run: |
          ts() { date -u '+%Y-%m-%d %H:%M:%S'; }

          INSTANCE_ID="${ACTIVATED_INSTANCE_ID:-$EDCLOUD_INSTANCE_ID}"
          if [[ -z "$INSTANCE_ID" ]]; then
            INSTANCE_ID="$(aws ec2 describe-instances \
              --filters \
                Name=tag:edcloud:managed,Values=true \
                Name=tag:Name,Values=edcloud \
                Name=instance-state-name,Values=pending,running,stopping,stopped \
              --query "Reservations[].Instances[] | sort_by(@, &LaunchTime)[-1].InstanceId" \
              --output text)"
          fi
          if [[ -z "$INSTANCE_ID" || "$INSTANCE_ID" == "None" ]]; then
            echo "No edcloud instance found to deactivate."
            exit 0
          fi

          echo "[$(ts) GITHUB] EDCLOUD_DEACTIVATE_BEGIN instance_id=$INSTANCE_ID" >> /tmp/github.log
          echo "üõë Stopping edcloud instance..."
          aws ec2 stop-instances --instance-ids "$INSTANCE_ID" >/dev/null

          echo "‚è≥ Waiting for instance to stop..."
          aws ec2 wait instance-stopped --instance-ids "$INSTANCE_ID"

          echo "[$(ts) GITHUB] EDCLOUD_DEACTIVATE_COMPLETE instance_id=$INSTANCE_ID" >> /tmp/github.log
          echo "‚úÖ edcloud infrastructure deactivated"

      - name: Summary
        run: |
          echo "## ‚úÖ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Mode**: ${{ steps.mode.outputs.mode_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL**: ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
